자바스크립트는 크게 원시타입(숫자, 문자열, 불리언, null, undefined, 심벌) 객체 타입으로 구분할 수 있다. 
원시 타입의 값은 변경 불가능 한 값이다. 반대로 객체 타입의 값은 변경 가능한 값이다.
원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다.
이에 비해 객체를 변수에 할당하면 참조 값이 저장된다. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이것을 값에 의한 전달 (pass by value)라 한다. 같은 값을 갖더라도 새로운 공간에 저장되는 별개의 값을 명심.

자바스크립트 엔진을 구현하는 제조사에 따라 내부 방식은 미묘한 차이가 있을 수 있는데 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 값을 참조하다가 어느 한쪽 변수가 재할당 되었을때 새로운 메모리 공간에 재할당된 값을 저장하도록 동작 할 수도 있다.

이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이것을 참조에 의한 전달이라고 한다.

*참조값: 생성된 객체가 저장된 메모리 공간의 주소. 값이 아니다.

원시 값이 변경 불가능하다는 말은 원시 값 자체를 변경할 수 없다는 것이지, 원시 값이 담겨져 있는 변수를 변경 할 수 없다는 말은 아니다. 변수의 값은 재할당을 통해 변경 할 수 있다.

변수의 상대 개념인 상수는 재할당이 금지된 변수를 말한다. 상수와 변경 불가능한 값인 원시값이 언뜻보면 비슷한 개념 같지만 동일시 하는 것은 틀린 말이다.
예를들어 상수를 사용한 변수 값에 원시값을 넣었을 경우 변경이 불가능하지만.
const s = {}; 상수 키워드를 사용해 객체 리터럴 값을 할당한 경우 재할당만 하지 않고 프로퍼티의 값을 추가하는 것과 같이 변수에 할당된 객체를 변경할 수 있다. 즉 재할당만 하지 않으면 변경 가능하다는 소리다.

불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.
즉 메모리 주소가 바뀌는 수 밖에 없다.

문자열은 0개 이상의 문자로 이뤄진 집합을 말하며 1개의 문자는 2바이트의 메모리 공간에 저장됨.
숫자는 숫자의 크기와 상관없이 8바이트가 필요하다.

문자열은 유사 배열 객체이며 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

유사 배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근 할 수 있고 lenth 프로퍼티를 갖는 객체를 말하는 것. 문자열은 배열처럼 인덱스를 통해 각 문자에 접근 가능하고 length 프로퍼티를 갖기 때문에 유사 배열 객체이며 for문으로 순회 가능하다.

---
객체는 프로퍼티 개수가 정해져 있지 않고 변경 가능한 값이므로 원시 값과 다르게 사전에 확보해야 할 메모리의 크기를 정할 수 없다. 때문에 히든 클래스라는 방식을 사용해 C++이 객체의 프로퍼티에 접근하는 정도의 성능을 보장하며 자바와 같이 고정된 객체 레이아웃(클래스)와 유사하게 동작한다.

객체는 언급했듯이 변경 가능한 유동적인 값이라 메모리를 재할당 하지 않게 설계되어 있어 메모리의 효율적인 사용이 가능한 장점이 있지만 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 단점이다 있다. 하나의 식별자의 값을 수정하면 다른 식별자의 값도 변하게 된다.

얕은 복사와 깊은 복사

얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체의 중첩되어 있는 객체까지 모두 복사하는 것을 말한다. 둘 다 원본과 참조 값이 다른 별개의 객체이지만 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하여 원시 값처럼 완전한 복사본을 만든다는 차이가 있다.


@@@@@@@@@@@@@@@@@
원시 타입의 값은 변경 불가능 한 값이다. 반대로 객체 타입의 값은 변경 가능한 값이다.
원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다.
이에 비해 객체를 변수에 할당하면 참조 값이 저장된다. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이것을 값에 의한 전달 (pass by value)라 한다. 같은 값을 갖더라도 새로운 공간에 저장되는 별개의 값을 명심.

자바스크립트 엔진을 구현하는 제조사에 따라 내부 방식은 미묘한 차이가 있을 수 있는데 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 값을 참조하다가 어느 한쪽 변수가 재할당 되었을때 새로운 메모리 공간에 재할당된 값을 저장하도록 동작 할 수도 있다.

이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다
참조값: 생성된 객체가 저장된 메모리 공간의 주소. 값이 아니다.

원시 값이 변경 불가능하다는 말은 원시 값 자체를 변경할 수 없다는 것이지, 원시 값이 담겨져 있는 변수를 변경 할 수 없다는 말은 아니다. 변수의 값은 재할당을 통해 변경 할 수 있다.

변수의 상대 개념인 상수는 재할당이 금지된 변수를 말한다. 상수와 변경 불가능한 값인 원시값이 언뜻보면 비슷한 개념 같지만 동일시 하는 것은 틀린 말이다.
예를들어 상수를 사용한 변수 값에 원시값을 넣었을 경우 변경이 불가능하지만.
const s = {}; 상수 키워드를 사용해 객체 리터럴 값을 할당한 경우 재할당만 하지 않고 프로퍼티의 값을 추가하는 것과 같이 변수에 할당된 객체를 변경할 수 있다. 즉 재할당만 하지 않으면 변경 가능하다는 소리다.

문자열은 유사 배열 객체이며 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

유사 배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근 할 수 있고 lenth 프로퍼티를 갖는 객체를 말하는 것. 문자열은 배열처럼 인덱스를 통해 각 문자에 접근 가능하고 length 프로퍼티를 갖기 때문에 유사 배열 객체이며 for문으로 순회 가능하다.

객체는 언급했듯이 변경 가능한 유동적인 값이라 메모리를 재할당 하지 않게 설계되어 있어 메모리의 효율적인 사용이 가능한 장점이 있지만 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 단점이다 있다. 하나의 식별자의 값을 수정하면 다른 식별자의 값도 변하게 된다.

얕은 복사와 깊은 복사

얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체의 중첩되어 있는 객체까지 모두 복사하는 것을 말한다. 둘 다 원본과 참조 값이 다른 별개의 객체이지만 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하여 원시 값처럼 완전한 복사본을 만든다는 차이가 있다.
