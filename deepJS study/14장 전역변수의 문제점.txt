
변수 호이스팅은 전역변수에 한에서 실행되는 것이다. 지역변수는 함수호출시 생성, 함수 종료시 소멸됨.

선언된 지역변수는 함수가 생성한 스코프에 등록된다. 대부분의 지역변수는 함수의 종료시에 소멸되기는 하지만 예외적으로 함수가 종료 되었을때도 스코프를 참조하고 있다면 등록된 지역변수 역시 스코프가 소멸되지 않고 있으므로 소멸되지 않는다.

@@@@@@@@여기서 질문: 지역 스코프가 참조되는 예시는 무엇인가? 말이 이해가 안됨.

function name_ (){...code};
name_(); 이렇게 호출되고 종료 됐을때 지역변수가 사라지는게 아니라

var A = function(){...let b; } 이렇게 함수가 변수에 할당되어 참조될때 지역스코프가 살아있다는 의미인가요?


호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 특징이다.
지역변수는 지역스코프의 맨 위 상단으로 끌어올려짐
전역변수는 전역스코프의 맨 위 상단으로 끌어올려짐


var 키워드로 작성한 전역변수는 전역객체의 프로퍼티 값이다.
전역객체: 전역객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이다. 전역객체는 브라우저 환경에서는 window, 서버 환경에서는 global 객체를 의미한다. 이렇게 환경에 따라 전역객체를 가리키는 식별자가 다양했지만 ES11에서 globalThis로 통일되었다.

전역변수의 단점

암묵적 결합: 재선언 재할당 될 수 있기 때문에 코드의 손상의 위험도가 높아짐

긴 생명주기: 전역변수는 전역객체와 수명이 같기 때문에 메모리 리소스 비용이 커진다.
스코프 체인 상에서 종점에 존재: 참조시에 가장 마지막 순서이기 때문에 속도가 느려진다.

네임스페이스 오염: 파일이 분리되어 있더라도 전역 스코프를 공유한다. 따라서 전역변수의 이름이 겹칠경우 오류가 생길 수 있음.

---
전역변수 사용 억제방법: 즉시 실행함수로 모든 코드롤 감싸기, 네임스페이스 역할을 할 객체를 생성하고 전역변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하기, 모듈패턴 사용하기, ES6 모듈 사용

모듈패턴: 모듈패턴은 관련이 있는 변수와 함수를 모아 즉시 실행함수로 감싸 하나의 모듈을 만드는 것. 캡슐화 구현 가능.
캡슐화: 프로퍼티와 메서드를 하나로 묶는 것.

==> 객체랑 비슷하다고 이해

ES6 모듈: 이것을 사용하면 전역변수를 사용할 수 없다. 파일자체의 독자적인 모듈 스코프를 제공하기 때문. 브라우저 호환성이 좋지 않아 아직은 잘 사용되지 않음. Webpack등의 모듈 번들러를 사용하는 것이 일반적.

