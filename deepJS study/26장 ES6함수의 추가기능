ES6 이전에는 함수가 목적에 맞지 않게 사용될 수 있으므로 성능면에서 좋지 않다. (생성자 함수로 안썻는데 프로토타입이 자동 생성되는것.)

ES6에서의 메서드
메서드 축약 표현으로 정의된 함수만을 의미함. 인스턴스를 생성할 수 없는 non-constructor다.
인스턴스를 생성할 수 없으므로 프로토타입 프로퍼티가 없고 프로토타입도 생성하지 않는다.
ES6의 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[homeObject]]를 가짐. super 참조는 이것을 사용하여 수퍼클래스의 메서드를 참조하기 때문에 ES6의 메서드는 super키워드를 사용할 수 있음.
즉 축약표현을 쓰지 않은 함수는 super키워드 사용 불가. homeObject가 없기 때문.
위의 이유로 프로퍼티 값으로 익명함수를 할당하는 ES6의 방식은 사용하지 않는 것이 좋다.

화살표 함수.
함수 표현식으로 정의해야한다.
매개변수가 여러 개인 경우 소괄호 () 안에 매개변수를 선언한다.
매개변수가 하나인 경우 소괄호 ()를 생략할 수 있다.
매개변수가 없는 경우 소괄호를 () 생략할 수 없다.
함수 몸체에 중괄호를 쓰지 않으려면 표현식으로 이루어진 하나의 문을 사용해야한다. 표현식인 문은 자동으로 반환된다.
표현식이 아닌 문을 사용할 경우 중괄호 생략 불가. 

객체 리터럴을 반환하는 경우-475p
객체 리터럴을 반환하는 경우 ( {} ) 객체 리터럴을 소괄호로 감싸 주어야 한다.
화살표 함수도 즉시 실행 함수로 사용할 수 있다.-476p

화살표 함수와 일반 함수의 차이.
화살표 함수는 인스턴스를 생성할 수 없는 non-constructor다. 때문에 prototype 프로퍼티가 없고 프로토타입도 생성하지 않음.
중복된 매개변수 이름을 선언할 수 없다. 일반함수는 매개변수의 이름이 중복되도 상관없음.
화살표 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다. 함수 내부에서 이것을 참조하면 스코프 체인을 따라 올라가 해당 this참조.
화살표 함수가 중첩되어 있는 경우에도 같음.
함수 자체의 this바인딩을 갖지 않으므로 call / apply / bind 등의 메서드를 사용해도 this를 교체할 수 없음.

화살표 함수와 일반함수와 구별되는 가장 큰 차이는 this.
일반함수 호출시 this는 전역객체를 가리킴. 화살표 함수 내부에는 this가 바인딩되어 있지 않아 스코프체인을 따라 올라감.(콜백함수에서 유용)
렉시컬 this라고 함.
화살표 함수를 사용하지 않는 방법: this를 변수에 따로 담기 / 메서드의 인수로 this 전달하기 / bind 메서드를 통해 this를 호출한 객체에 묶어두기

화살표 함수에는 super 바인딩 값이 존재 하지 않아, 화살표 함수 내에서 super를 참조하면 this와 마찬가지로 상위 스코프를 찾아감.

rest 문법
...을 쓰면 나머지 인수를 전달 받을 수 있음. 하나만 써야하고 , 마지막에 써야함. 배열로 전달된다!!!
ES6에서는 function(){~~code} 처럼 매개변수의 수가 정해져 있지 않은 가변함수의 경우 arguments 객체를 변환시켜서 사용해야 했지만.
function(...args){~~code} 같이 rest문법을 쓰면,  function(a,b,c) 이렇게 인자를 임의로 정해두어도 함수 인자를 쉽게 전달할 수 있다.

매개변수의 기본값
매개변수가 전달되지 않을 경우 기본값을 설정해 오류를 방지 할 수 있다.
rest 파라미터 값에는 기본값을 설정할 수 없다!!









