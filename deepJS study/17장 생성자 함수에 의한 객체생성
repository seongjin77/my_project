객체 리터럴로 객체를 생성하는 방법말고 생성자 함수로 객체를 생성하는 방법

생성자 함수란  new연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 인스턴스란 생성자 함수에 의해 생성된 객체를 말한다.
new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.

Object 생성자 함수 외에도 String, Boolean, Function, Array, Date, RegExp, Promise 등의 빌트인 생성자 함수가 있다. 

생성자 함수의 장점
객체 리터럴로 객체를 생성하면 직관적이고 손쉽게 만들 수 있지만 하나의 객체밖에 생성하지 못한다. 때문에 객체를 여러개 생성해야할때 프로퍼티의 구조나 메서드들이 중복되어 비용을 증가 시킨다. 이때 생성자 함수를 사용한다면 프로퍼티 구조가 동일한 객체를 여러개 만들 수 있다.

This는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 참조 변수이다. this가 가리키는 값은 함수 호출 방식에 따라 동적으로 작용하는데, 일반 함수에서는 전역객체를, 메서드에서는 메서드를 호출한 객체를, 생성자 함수로 호출될때는 생성자 함수가 미래에 생성할 인스턴스를 가리킨다.

생성자 함수의 역할은 인스턴스를 생성하는것, 생성된 인스턴스를 초기화하는 것이다. 자바스크립트 엔진은 암묵적으로 인스턴스를 생성하고 반환한다. 따로 반환코드를 써주지 않아도 된다.

생성자 함수의 인스턴스 생성 매커니즘은 우선 암묵적으로 인스턴스가 생성되고 this에 바인딩 되는 것이다. 두번째로 this에 바인딩되어 있는 인스턴스를 초기화한다. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 이때 반환문을 따로 적어주면 this는 무시되고 return문에 명시한 객체가 반환된다.
하지만 또 return문에 원시값을 적으면 원시값은 무시되고 this가 반환된다.

이렇게 반환문을 사용하면 인스턴스가 훼손될 수 있으므로 return문 사용은 지양해야한다.

함수는 객체로서 작용할 수 있고 다른 객체와는 다르게 호출될 수도 있다. 때문에 일반 함수로 호출되느냐 생성자 함수로서 호출되느냐에 따라 내부 메서드가 다르게 작용한다.
일반함수일때 [[call]] 생성자 함수일때 [[construct]]

내부메서드에 따라 다르게 불린다.
callable: 호출 할 수 있는 객체(일반함수), constructor: 생성자 함수로서 호출 할 수 있는함수, non-constructor : 생성자 함수로서 호출할 수 없는 함수
요약하면 모든 함수는 호출할 수 있으므로 callable이면서 contructor 또는 non-constructor로 나뉨

contructor: 함수선언문, 함수표현식, 클래스
non-constructor의 예 > 메서드,화살표함수

이때의 메서드는 일반적으로 우리가 알고 있는 프로퍼티 값으로 사용되는 함수가 아니라 ES6의 함수 축약표현으로 표현된 함수를 말한다.

new 연산자 없이 사용하면 생성자 함수가 일반함수로 호출되기 때문에 이러한 문제점을 해결하기 위해 파스칼케이스로 명명하여 실수를 줄이는 방법도 있겠지만 new.target을 사용한다.
new.target은 this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 불린다. 함수 내부에서 사용하면 new.target은 함수 자신을 가리키고 일반함수로 호출되었다면 undefined값이 나온다.

IE에서는 지원하지 않는데 이 경우에는 스코프 세이프 생성자 패턴을 사용한다.

대부분의 빌트인 생성자 함수 Object, String, Number, Boolean등등 은 new 연산자가 사용되었는지 유무에 따라 반환되는 값이 달라져서 new.target 같은 방법을 쓰지 않아도 알 수 있다.

----------

![](https://velog.velcdn.com/images/tchaikovsky/post/a06822a5-05ca-4abc-84d2-6a44928da6b9/image.PNG)
new 연산자를 사용하여 호출하였을때 String,Number 모두 객체로 생성된다고 하여 콘솔에 찍어보니 객체로 생성되었다.
조금 이해가 안되는 점은 객체로 담겼기에 for...in문으로도 탐색할 수 있고, 하나의 값(생성자 함수에 인수로 전달한 값)이 담겨 있을 줄 알았으나, 입력한 값이 하나의 프로퍼티에 담기는게 아니고
인덱스 당 하나의 문자열(여기서는 숫자 하나)을 값으로 갖는 프로퍼티 키 - 프로퍼티 값의 형태로 생성되었다.
그리고 지수로 바꾸어 할당됨을 알 수 있었다.

![](https://velog.velcdn.com/images/tchaikovsky/post/d789e1af-a511-4fee-b922-e21c3e1173e9/image.PNG)
문자로 해당 숫자를 바꾸기 이전에 먼저 지수처리를 한 뒤에 객체로 할당되며, 할당 될 때에는 인덱스를 프로퍼티 키로, 값을 한개의 문자열로 갖는 객체로 만들어진다.
