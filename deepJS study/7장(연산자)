연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해
하나의 값을 만든다. 연산의 대상은 피연산자라 하며 피연산자 역시 값으로 표현될 수 있는 표현식이어야
한다.

산술 연산자는 이항 산술 연산자와 단항 산술 연산자로 구분한다.

이항 산술 연산자: 피연산자의 값을 변경하지 않고 새로운 값을 만든다. 
단항 산술 연산자: 1개의 피연산자를 산술 연산하여 숫자 값을 만든다. 

피연산자 앞에 단항 산술 연산자가 있으면 먼저 피연산자의 값을 증감시킨 후 다른 연산을 수행,
피연산자 뒤에 단항 산술 연산자가 있으면 다른 연산을 수행하고 피연산자의 값을 증감시킨다.

+단항 연산자는 아무런 효과가 없지만 숫자가 아닌 타입의 피연산자 앞에 사용할 경우
피연산자를 숫자 타입으로 변환하여 반환한다. 피연산자를 직접 변경하는 것은 아니고
숫자 타입으로 변환한 값을 생성해서 반환하는 것이다.


-단항 연산자도 마찬가지로 숫자 타입이 아닌 피연산자 앞에 사용할 경우 숫자타입으로 변환한 값을
생성하여 반환한다. 다만 피연산자의 부호를 반전한 값을 반환한다.

1 + ture를 연산하면 true는 자바스크립트 엔진에 의해 불리언 타입의 값이 숫자 타입인 1로 변경된다
이것을 암묵적 타입변환 또는 타입 강제 변환이라고 한다.

할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에~~가 어려워서
왼쪽에 있는 부호를 먼저 처리하고 할당한다 라고 이해.

표현식은 값으로 평가될 수 있는 문이고, 표현식이 아닌 문도 있다. 이것을 확인하는 방법은
변수에 값을 할당 할 수 있는 가로 판별할 수 있다.

할당문은 단순이 변수에 값을 할당하는 부수효과만 있는것처럼 보이지만 값으로 평가되는 표현식인
문으로서 할당된 값으로 평가된다.

그렇다면 변수에 할당문을 할당 할 수 있겠다는 생각이 들었다.


;비교 연산자는 동등 비교와 일치 비교로 나누어지는데 동등비교는 데이터의 값만 비교하고
연산자 일치 비교는 타입과 값을 같이 비교하는 엄격한 비교이다.

;비교연산자에서도 암묵적 타입 변환이 일어나 타입을 일치시킨 후 같은 값인지 비교하는 매커니즘을
가지고 있다. 따라서 비교 연산자는 타입이 다르더라도 값이 같다면 true를 반환한다.

;이것은 예측하기 어려운 결과를 만들 수 있으므로 오류를 줄이려면 타입과 값도 같은 경우인
일치 비교 연산자를 사용하는 편이 좋다 예외적으로는 NaN (Not a number)가 있는데 유일하게
자신과 일치하지 않는 값이다. 따라서 숫자가 NaN인지 조사하려면 Number.isNaN를 사용해야한다.

;또한 자바스크립트에는 +0과 -0의 값이 있는데 이것또한 동일하다고 평가하니 주의할 것

;이것은 ES6에서 도입된 Object.is 메서드를 통하여 예측 가능한 정확한 비교 결과를 반환하기 때문이다.

삼항 조건 연산자: 조건식(불리언 타입의 값으로 평가되어야함)? true일때 반환할 값 : false일때

;if else문과 비슷하지만 중요한 차이점은 삼항 조건 연산자 표현식은 값처럼 사용할 수 있지만
if else문은 값처럼 사용할 수 없다. 따라서 변수에 할당 불가능함.

논리 연산자: || && ! 등이 있다. 
논리부정 ! 연산자는 언제나 불리언 값을 반환한다. 단 피연산자가 불리언일 필요는 없다. 피연산자가
불리언 값이 아닐경우 암묵적 타입 변환을 통해 값을 반환하기 때문이다.

논리합과 논리곱의 평가 결과는 불리언 값이 아닐 수도 있다. 두개의 피연산자 중 어느 한쪽으로 평가된다.

논리 연산자가 복잡할경우 드 모르간의 법칙을 쓰면 좀 쉽게 이해할 수 있다.

쉽표 연산자 , 는 왼쪽부터 피연산자를 평가하고 마지막 피연산자의 값을 반환한다.

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다. 하지만 typeof 연산자가 반환하는
문자열은 7개의 데이터 타입과 정확히 일치하지 않는데 예로는 null 타입을 null로 반환하지 않고
object로 반환한다. 자바스크립트의 버그며 기존 코드에 영향을 줄 수 있기 때문에 아직 수정은 안된다
때문에 값이 null인지 확인하기 위해서는 typeof 연산자를 사용하지 말고 일치 연산자를 사용한다.
또한 선언되지 않은 식별자를 연산할때 에러가 나지 않고 undefined 값이 반환되니 주의할 것.

지수연산자 **는 이항 연산자 중에서 우선순위가 가장 높다.
2*5**2 / 50


@@@@@@@@@@@@@@@@@@@@@@@@@


연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해
하나의 값을 만든다. 연산의 대상은 피연산자라 하며 피연산자 역시 값으로 표현될 수 있는 표현식이어야
한다.

피연산자 앞에 단항 산술 연산자가 있으면 먼저 피연산자의 값을 증감시킨 후 다른 연산을 수행,
피연산자 뒤에 단항 산술 연산자가 있으면 다른 연산을 수행하고 피연산자의 값을 증감시킨다.

+단항 연산자는 아무런 효과가 없지만 숫자가 아닌 타입의 피연산자 앞에 사용할 경우
피연산자를 숫자 타입으로 변환하여 반환한다. 피연산자를 직접 변경하는 것은 아니고
숫자 타입으로 변환한 값을 생성해서 반환하는 것이다.


-단항 연산자도 마찬가지로 숫자 타입이 아닌 피연산자 앞에 사용할 경우 숫자타입으로 변환한 값을
생성하여 반환한다. 다만 피연산자의 부호를 반전한 값을 반환한다.

1 + ture를 연산하면 true는 자바스크립트 엔진에 의해 불리언 타입의 값이 숫자 타입인 1로 변경된다
이것을 암묵적 타입변환 또는 타입 강제 변환이라고 한다.

;할당문은 단순이 변수에 값을 할당하는 부수효과만 있는것처럼 보이지만 값으로 평가되는 표현식인
문으로서 할당된 값으로 평가된다.

;비교 연산자는 동등 비교와 일치 비교로 나누어지는데 동등비교는 데이터의 값만 비교하고
연산자 일치 비교는 타입과 값을 같이 비교하는 엄격한 비교이다.

;비교연산자에서도 암묵적 타입 변환이 일어나 타입을 일치시킨 후 같은 값인지 비교하는 매커니즘을
가지고 있다. 따라서 비교 연산자는 타입이 다르더라도 값이 같다면 true를 반환한다.

이것은 예측하기 어려운 결과를 만들 수 있으므로 오류를 줄이려면 타입과 값도 같은 경우인
일치 비교 연산자를 사용하는 편이 좋다 예외적으로는 NaN (Not a number)가 있는데 유일하게
자신과 일치하지 않는 값이다. 따라서 숫자가 NaN인지 조사하려면 Number.isNaN를 사용해야한다.

;또한 자바스크립트에는 +0과 -0의 값이 있는데 이것또한 동일하다고 평가하니 주의할 것

;이것은 ES6에서 도입된 Object.is 메서드를 통하여 예측 가능한 정확한 비교 결과를 반환하기 때문이다.

삼항 조건 연산자: 조건식(불리언 타입의 값으로 평가되어야함)? true일때 반환할 값 : false일때

if else문과 비슷하지만 중요한 차이점은 삼항 조건 연산자 표현식은 값처럼 사용할 수 있지만
if else문은 값처럼 사용할 수 없다. 따라서 변수에 할당 불가능함.

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다. 하지만 typeof 연산자가 반환하는
문자열은 7개의 데이터 타입과 정확히 일치하지 않는데 예로는 null 타입을 null로 반환하지 않고
object로 반환한다. 자바스크립트의 버그며 기존 코드에 영향을 줄 수 있기 때문에 아직 수정은 안된다
때문에 값이 null인지 확인하기 위해서는 typeof 연산자를 사용하지 말고 일치 연산자를 사용한다.
또한 선언되지 않은 식별자를 연산할때 에러가 나지 않고 undefined 값이 반환되니 주의할 것.

지수연산자 **는 이항 연산자 중에서 우선순위가 가장 높다.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

연산자의 정의에 대해 알았음 그리고 단항산술 연산자가 앞에 붙느냐 뒤에 붙느냐가 쉬운거지만 계속
헷갈렸었는데 이번에 앞에 붙으면 피연산자를 먼저 증감시키고 평가를 한다는 것을 확실히 알았음

또한 + 단항 산술자는 아무런 효과도 없는데 왜 있을까 라는 고민을 햇는데 숫자가 아닌 피연산자의
타입을 변경하여 값을 반환하는 것이라는 걸 알게 되었습니다. 다만 피연산자의 타입을 직접 변경하는
것이 아닌 숫자타입으로 변경한 값을 반환하는 점이 인상깊었

이렇게 타입이 변환되는 것을 암묵적 타입 변환이라고 부르는데 
예로 1 + true를 하면 트루가 1로 변하는 것을 생각
할 수 잇습니다.

동등 연산자에 대한 예외결과 