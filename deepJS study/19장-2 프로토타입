생성자 함수에 의해 생성된 객체(인스턴스)는, 프로토타입의 constructor라는 프로퍼티에 의해 생성자 함수와 연결된다.

생성자 함수로 생성한 객체가 아니라, 객체 리터럴로 생성한 객체의 경우도, 생성자 함수로 만든 객체로 봐도 무방하다. 리터럴로 생성한 객체는 생성자 함수로 만든 객체와 생성과정의 약간의 차이만 있을뿐 큰 틀에서 객체로서의 동일한 특성을 갖는다. 따라서 객체리터럴로 만든 객체의 프로토타입의 constructor가 가리키는 생성자 함수는, 생성자 함수로 만든 객체의 프로토타입의 constructor가 가리키는 생성한 생성자 함수로 생각해도 된다.
-객체 리터럴로 객체가 생성될때 가상의 생성자 함수가 만들어지기 때문이다. 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 쌍으로 존재.

프로토타입은 생성자 함수가 생성될 때 같이 생성된다. 즉 생성자 함수로 호출할 수 있는 constructor가 평가되어 객체를 생성하는 시점에 프로토타입도 동시에 생성된다. 또한 이 프로토타입의 프로토타입은 최상위 객체 프로토타입인 Object.prototype이다. 이것 역시 생성자 함수가 생성될 때 같이 생성된다.

전역객체: 전역객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체다. 브라우저에서는 window, node.js에서는 global객체를 가리킨다. 전역객체는 표준 빌트인 객체인 Object, String, Nember 등을 프로퍼티로 갖는다.

프로토타입도 객체임으로 프로퍼티를 추가/삭제할 수 있다.
obj.prototype.key = fuction(){...code}; 
생성자 함수가 생성하는 모든 인스턴스는 prototype의 메서드를 공유해서 사용할 수 있다.

프로토타입 체인: 객체의 프로퍼티에 접근할때 해당 객체의 찾는 프로퍼티가 없다면 부모 역할을 하는 프로토타입의 프로퍼티를 순착적으로 검색한다. 스코프 체인과 비슷하다고 이해. 체인을 따라 올라가 프로퍼티를 검색했는데도 없는경우 에러가 아니라 undefined값을 반환한다. 차이점은 스코프 체인은 식별자를 검색하는 것이고 프로토타입 체인은 프로퍼티를 검색하는 것이다.

제일 중요하다고 생각되는 부분은 어떤 생성자 함수로 만든 객체에 일일히 메소드를 추가하여 사용하는 것보다 상위 프로토타입에 메소드를 추가하여 사용할 수 있게 하는게 비용 측면에서 도움이 될 수 있겠구나 생각했습니다.



;객체를 생성할 때 다양한 방법들이 있지만 모두 추상 연산 OrdinaryObjectCreate에 의해 생성된다.
추상 연산 OrdinaryObjectCreate는 자신이 생성할 객체의 프로토타입을 인수로 전달받는다. 이 인수는 객체가 생성되는 방식에 의해 결정되고 객체의 프로토타입을 결정한다.
